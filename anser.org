* Migration Status
** Create anser.records
stores documents that map a migration run (e.g. a UUID ID for the migration run, and some metadata about that migration like runtime, migrations completed.)
** Create anser.migrations
mapping of a record ID with some sort of unique identifier for the migration, so we can check to see if a migration has completed in this run. this is where we'll store total documents needed, total documents changed, etc.
** Create interface for the model
need functions to help us store this data and access it during the run.
* Migration Generators
For each migration there'll need to be a generator that runs in a job and runs a query to create migration jobs.

Generators have an ID (e.g. a common name), and a specific name for the run instance. The ID of the generator is derived from the combination of these two identifiers.

Generators can run/interleave with other tasks (for simple renames or ETL type operations, etc.) [no dependencies]

Or run after a previous generator runs [generator dependencies]

Or run after the migrations generated by a previous generator [task dependencies].
* DONE Simple Migrations                                            :ARCHIVE:
Simple migrations are operations that transform a single document.

A migration will be a struct with the following fields:
- db,
- collection,
- input document id
- a change specification, which is:
  - bson.M (e.g. update query)
  - func(rawBSON) interface{} (e.g. arbitrary function to transform the bson)
* DONE Aggregate Migrations                                         :ARCHIVE:
Some migrations take as an input an iterator of some sort, and perform an operation on that. For example "do this query, and run update all," or more likely aggregate these input documents and write a single output document.

It might not be worth it to implement this.
* DONE Freeform Migration                                           :ARCHIVE:
same thing as the simple migration but you get an interface handed to you with a DB handle
* DONE Migration Job Implementations                                :ARCHIVE:
* Tasks
** TODO multi update with limit
** TODO write arbitrary function wrappers that are not tied to specific documents
** TODO sketch out generators
** TODO
